import { dirname, join, parse, basename, relative, resolve } from 'path';
import { readJSON, remove, readdirSync, existsSync } from 'fs-extra';
import {
  debug,
  download,
  execCommand,
  FileFsRef,
  getNodeVersion,
  getSpawnOptions,
  glob,
  Lambda,
  NodejsLambda,
  readConfigFile,
  runNpmInstall,
  runPackageJsonScript,
  scanParentDirs,
  Prerender,
  BuildV2,
  PackageJson,
} from '@vercel/build-utils';
import { buildVercelOutput } from '.';

function hasScript(scriptName: string, pkg: PackageJson | null) {
  const scripts = (pkg && pkg.scripts) || {};
  return typeof scripts[scriptName] === 'string';
}

export const build: BuildV2 = async ({
  entrypoint,
  files,
  workPath,
  config,
  meta = {},
}) => {
  await download(files, workPath, meta);

  const { installCommand, buildCommand } = config;
  const mountpoint = dirname(entrypoint);
  const entrypointFsDirname = join(workPath, mountpoint);
  const nodeVersion = await getNodeVersion(
    entrypointFsDirname,
    undefined,
    config,
    meta
  );

  const spawnOpts = getSpawnOptions(meta, nodeVersion);
  if (!spawnOpts.env) {
    spawnOpts.env = {};
  }
  const { cliType, lockfileVersion } = await scanParentDirs(
    entrypointFsDirname
  );

  if (cliType === 'npm') {
    if (
      typeof lockfileVersion === 'number' &&
      lockfileVersion >= 2 &&
      (nodeVersion?.major || 0) < 16
    ) {
      // Ensure that npm 7 is at the beginning of the `$PATH`
      spawnOpts.env.PATH = `/node16/bin-npm7:${spawnOpts.env.PATH}`;
      console.log('Detected `package-lock.json` generated by npm 7...');
    }
  } else if (cliType === 'pnpm') {
    if (typeof lockfileVersion === 'number' && lockfileVersion === 5.4) {
      // Ensure that pnpm 7 is at the beginning of the `$PATH`
      spawnOpts.env.PATH = `/pnpm7/node_modules/.bin:${spawnOpts.env.PATH}`;
      console.log('Detected `pnpm-lock.yaml` generated by pnpm 7...');
    }
  }

  if (typeof installCommand === 'string') {
    if (installCommand.trim()) {
      console.log(`Running "install" command: \`${installCommand}\`...`);

      const env: Record<string, string> = {
        YARN_NODE_LINKER: 'node-modules',
        ...spawnOpts.env,
      };

      await execCommand(installCommand, {
        ...spawnOpts,
        env,
        cwd: entrypointFsDirname,
      });
    } else {
      console.log(`Skipping "install" command...`);
    }
  } else {
    await runNpmInstall(entrypointFsDirname, [], spawnOpts, meta, nodeVersion);
  }

  // Run "Build Command"
  if (buildCommand) {
    debug(`Executing build command "${buildCommand}"`);
    await execCommand(buildCommand, {
      ...spawnOpts,
      cwd: entrypointFsDirname,
    });
  } else {
    const pkg = await readConfigFile<PackageJson>(
      join(entrypointFsDirname, 'package.json')
    );
    if (hasScript('vercel-build', pkg)) {
      debug(`Executing "yarn vercel-build"`);
      await runPackageJsonScript(
        entrypointFsDirname,
        'vercel-build',
        spawnOpts
      );
    } else if (hasScript('build', pkg)) {
      debug(`Executing "yarn build"`);
      await runPackageJsonScript(entrypointFsDirname, 'build', spawnOpts);
    } else {
      await execCommand('gatsby build', {
        ...spawnOpts,
        cwd: entrypointFsDirname,
      });
    }
  }

  await buildVercelOutput();

  const staticOutput = await createStaticOutput({
    entrypointFsDirname,
  });

  const lambdas = await createLambdaOutput({
    entrypointFsDirname,
    nodeVersion,
  });

  const { routes } = await readJSON(
    join(entrypointFsDirname, '.vercel', 'output', 'config.json')
  );

  await remove(join('.vercel', 'output'));

  return {
    output: { ...staticOutput, ...lambdas },
    routes,
  };
};

async function* getFiles(dir: any): any {
  const files = readdirSync(dir, { withFileTypes: true });

  for (const file of files) {
    const res = resolve(dir, file.name);
    if (!file.isDirectory() && !file.isSymbolicLink()) return;

    if (!res.endsWith('.func')) {
      yield* getFiles(res);
    } else {
      yield res;
    }
  }
}

async function createLambdaOutput({
  entrypointFsDirname,
  nodeVersion,
}: {
  entrypointFsDirname: string;
  nodeVersion: Awaited<ReturnType<typeof getNodeVersion>>;
}) {
  const lambdas: { [key: string]: Lambda } = {};
  const functionDir = join(
    entrypointFsDirname,
    '.vercel',
    'output',
    'functions'
  );

  for await (const filePath of getFiles(functionDir)) {
    const lambdaFiles: Record<string, FileFsRef> = {};
    const functionFiles = Object.keys(await glob('**', filePath));

    functionFiles.forEach(async functionFile => {
      lambdaFiles[functionFile] = await FileFsRef.fromFsPath({
        fsPath: join(`${filePath}/${functionFile}`),
      });
    });

    const funcName = filePath
      .replace(functionDir, '')
      .replace('.func', '')
      .replace(/^\//, '');

    const lambda = new NodejsLambda({
      files: lambdaFiles,
      handler: 'index.js',
      runtime: nodeVersion.runtime,
      shouldAddHelpers: false,
      shouldAddSourcemapSupport: false,
    });

    const isPrerender = existsSync(
      join(functionDir, `${funcName}.prerender-config.json`)
    );

    if (isPrerender) {
      // @ts-ignore
      lambdas[funcName] = new Prerender({
        lambda,
        // Gatsby DSR doesn't have expiration or fallback
        expiration: false,
        fallback: null,
      });
    } else {
      lambdas[funcName] = lambda;
    }
  }

  return lambdas;
}

async function createStaticOutput({
  entrypointFsDirname,
}: {
  entrypointFsDirname: string;
}) {
  const staticOutput: Record<string, FileFsRef> = {};
  const staticDir = join(entrypointFsDirname, '.vercel', 'output', 'static');

  const staticFiles = await glob('**', staticDir);

  for (const [fileName, fileFsRef] of Object.entries(staticFiles)) {
    const parsedPath = parse(fileFsRef.fsPath);

    if (parsedPath.ext !== '.html') {
      staticOutput[fileName] = fileFsRef;
    } else {
      const fileNameWithoutExtension = basename(fileName, '.html');

      const pathWithoutHtmlExtension = join(
        parsedPath.dir,
        fileNameWithoutExtension
      );

      fileFsRef.contentType = 'text/html; charset=utf-8';

      staticOutput[relative(staticDir, pathWithoutHtmlExtension)] = fileFsRef;
    }
  }

  return staticOutput;
}
